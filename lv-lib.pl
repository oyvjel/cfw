# 
# Cumulus Firewall 
# Copyright (C) 2000  Øyvind Jelstad, Cumulus IT AS
# 
##### SE http://www.planetconnect.com/vlan/iptables-example.txt

# $Id: lv-lib.pl,v 1.31 2003/03/18 22:25:29 oyvind Exp $


package main;

$CFW="cfw";

sub generate_fw_script {

$log_non_sessions = $config{'log_non_sessions'};

$spf = $config{'stateful'};


    print "<BR><HR><pre>\n";


    $si = ($config{'scriptinterpreter'}) ? $config{'scriptinterpreter'} : "/bin/sh";
    $IPTABLES = ($config{'filter_path'}) ? $config{'filter_path'} : "/sbin/iptables";
    
    $LOOPBACK_INTERFACE="lo";                 # or your local naming convention
    $ANYWHERE="0.0.0.0/0";                        # match any IP address
    $LOOPBACK="127.0.0.0/8";                  # reserved loopback address range
    $CLASS_A="10.0.0.0/8";                    # class A private networks
    $CLASS_B="172.16.0.0/12";                 # class B private networks
    $CLASS_C="192.168.0.0/16";                # class C private networks
    $CLASS_D_MULTICAST="224.0.0.0/4";         # class D multicast addresses
    $CLASS_E_RESERVED_NET="240.0.0.0/5";      # class E reserved addresses
    $BROADCAST_SRC="0.0.0.0";                 # broadcast source address
    $BROADCAST_DEST="255.255.255.255";        # broadcast destination address
    $PRIVPORTS="0:1023";                      # well known, privileged port range
    $UNPRIVPORTS="1024:65535";                # unprivileged port range

    
  open(FILE, ">$config{'scriptfile'}") || &error($text{'sman_err_write'});
   print FILE "#!$si\n";
   print FILE "# Cumulus IT Firewalling Script File\n";
   print FILE "# Generated by Cumulus Firewall generator\n";
   print FILE "# Copyright (C) 2002 by Øyvind Jelstad, Cumulus IT AS\n";
   print FILE "# http://www.cumulus.no/\n";
   print FILE "# Created on ", &make_date(time), "\n";
#########################################################

print FILE <<EOM;
# ----------------------------------------------------------------------------
#  Stop or Start:

case "\$1" in
  stop)
  
  echo "Stopping  firewalling in \$2 seconds... "

  logger -p user.info -t cfw ADMIN: Stop: Stopping  firewalling in \$2 seconds... 


  sleep \$2
  
  echo "...now!"

 # Flush all rules
  echo -n "Flushing all rules ... "
    $IPTABLES -P INPUT ACCEPT
    $IPTABLES -P FORWARD ACCEPT
    $IPTABLES -P OUTPUT ACCEPT
    $IPTABLES -t nat -P PREROUTING ACCEPT
    $IPTABLES -t nat -P POSTROUTING ACCEPT
    $IPTABLES -t nat -P OUTPUT ACCEPT
    $IPTABLES -F
    $IPTABLES -t nat -F
    $IPTABLES -X
    $IPTABLES -t nat -X

    # Disnable IP spoofing protection
    # turn off Source Address Verification
    for f in /proc/sys/net/ipv4/conf/*/rp_filter; do
        echo 0 > \$f
    done

    logger -p user.info -t cfw ADMIN: Stop: Firewall is stopped
    echo "done."

    exit 0
;;

esac

EOM

print FILE "\necho Starting firewall.... \n" if $config{'verbose'};

######## INTERFACES ####################################
print FILE "\necho Computing interface addresses... \n" if $config{'verbose'};

print FILE "\n\n### Interface addresses ---------------------";
open(IF, " ifconfig -a |")  or die "Kan ikke &aring;pne ifconfig \n";


while (<IF>) {
   $L=$_;
    if ( $L =~ m/^([a-z0-9]*) *Link.*/ ) {
#       print "LINE = $L \n";
#	&skriv;
        print FILE "\nADR_$1=`/sbin/ifconfig $1 |sed -n -e \"s/ * inet addr:\\([\.0-9]*\\) .*/\\1/p\"`;";

    }    
}
print FILE "\n\n\n";
close IF;


##########################################################
print FILE <<EOM;

# ----------------------------------------------------------------------------
# echo "Starting firewalling... "


# ----------------------------------------------------------------------------

logger -p user.info -t cfw ADMIN: Start: Starting Cumulus Firewall


EOM
print FILE "\necho Loading modules... \n" if $config{'verbose'};
  
print FILE <<EOM;

#########
# Load all required IPTables modules
#

#
# Needed to initially load modules
#
# /sbin/depmod -a
  
#
# Adds some iptables targets like LOG, REJECT and MASQUARADE.
#
/sbin/modprobe ipt_LOG
  #/sbin/modprobe ipt_REJECT
  /sbin/modprobe ipt_MASQUERADE
  
#
# Support for owner matching
#
#/sbin/modprobe ipt_owner

#
# Support for connection tracking of FTP and IRC.
#
/sbin/modprobe ip_conntrack_ftp
/sbin/modprobe ip_nat_ftp

#/sbin/modprobe ip_conntrack_irc
#/sbin/modprobe ip_nat_irc

#/sbin/modprobe ip_conntrack_h323
#/sbin/modprobe ip_nat_h323

EOM

print FILE "\necho Flushing old policy...\n" if $config{'verbose'};

print FILE <<EOM;

# Reset all tables and policy.
# Default policy is DENY
    $IPTABLES -P INPUT DROP
    $IPTABLES -P FORWARD DROP
    $IPTABLES -P OUTPUT DROP
    $IPTABLES -t nat -P PREROUTING ACCEPT
    $IPTABLES -t nat -P POSTROUTING ACCEPT
    $IPTABLES -t nat -P OUTPUT ACCEPT
    $IPTABLES -F
    $IPTABLES -t nat -F
    $IPTABLES -X
    $IPTABLES -t nat -X
  


EOM

print FILE "\necho Setting kernel options... \n" if $config{'verbose'};

print FILE <<EOM;

# ----------------------------------------------------------------------------

    # Enable TCP SYN Cookie Protection
    echo 1 > /proc/sys/net/ipv4/tcp_syncookies

    # Enable always defragging Protection
#    echo 1 > /proc/sys/net/ipv4/ip_always_defrag

    # Enable broadcast echo  Protection
    echo 1 > /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts

    # Enable bad error message  Protection
    echo 1 > /proc/sys/net/ipv4/icmp_ignore_bogus_error_responses

    # Enable IP spoofing protection
    # turn on Source Address Verification
    for f in /proc/sys/net/ipv4/conf/*/rp_filter; do
        echo 1 > \$f
    done

    # Disable ICMP Redirect Acceptance
    for f in /proc/sys/net/ipv4/conf/*/accept_redirects; do
        echo 0 > \$f
    done

    # Disable Source Routed Packets
    for f in /proc/sys/net/ipv4/conf/*/accept_source_route; do
        echo 0 > \$f
    done

    # Log Spoofed Packets, Source Routed Packets, Redirect Packets
    for f in /proc/sys/net/ipv4/conf/*/log_martians; do
        echo 0 > \$f
    done

# Enable forwarding.
    echo "1" > /proc/sys/net/ipv4/ip_forward

#
# Dynamic IP users:
#
#echo "1" > /proc/sys/net/ipv4/ip_dynaddr

#
EOM
  
print FILE "\necho Helper chains... \n" if $config{'verbose'};
print FILE <<EOM;
# ----------------------------------------------------------------------------
# New chains:
if ! ( $IPTABLES -F LOGDROP >/dev/null 2>&1 ) ; 
  then 
   $IPTABLES -N LOGDROP
fi
$IPTABLES -F LOGDROP
# $IPTABLES -A LOGDROP -j LOG --log-prefix "LOGDROP " --log-ip-options --log-tcp-options
$IPTABLES -A LOGDROP -j LOG --log-prefix "$CFW:LOGDROP:DROP RULE= "

$IPTABLES -A LOGDROP -j DROP





# ----------------------------------------------------------------------------
# LOOPBACK

    # Unlimited traffic on the loopback interface.

    $IPTABLES -A INPUT  -i $LOOPBACK_INTERFACE  -j ACCEPT 
    $IPTABLES -A OUTPUT -o $LOOPBACK_INTERFACE  -j ACCEPT 


# MASQ timeouts
#
#   2 hrs timeout for TCP session timeouts
#  10 sec timeout for traffic after the TCP/IP "FIN" packet is received
#  60 sec timeout for UDP traffic (MASQ'ed ICQ users must enable a 30sec firewall timeout in ICQ itself)
#
# ipchains -M -S 7200 10 60

#

EOM


#################################################
## BLOCK LIST
$bfscript = $config{'bootloc'} ."/block";

if ( $config{'block'} ne "none" ) {
    print FILE "\necho Blocklist script start... \n" if $config{'verbose'};
    print FILE <<EOM;
# Blocklist support
    
if [ -x $bfscript ] ; then
   $bfscript;
fi

EOM
}

if ( $config{'block'} eq "rule0" ) {
    print FILE "\necho Blocklist at rule 0 \n" if $config{'verbose'};
  print FILE <<EOM;
# Blocklist
$IPTABLES -A  INPUT   -j BLOCK
$IPTABLES -A  FORWARD   -j BLOCK
$IPTABLES -A  OUTPUT   -j BLOCK

EOM

}


#####################################################



# Refuse incoming packets pretending to be from the external address.
#    ipchains -A input   -s $IPADDR -j DENY -l

if ( $config{'badaddr'} ) {
    print FILE "\necho Blocking bad addreses... \n" if $config{'verbose'};
     print FILE <<EOM;

# ----------------------------------------------------------------------------
# SPOOFING & BAD ADDRESSES
# Refuse spoofed packets.
# Ignore blatantly illegal source addresses.
# Protect yourself from sending to bad addresses.


    # Refuse incoming packets claiming to be from a Class A, B or C private network

    ##### MÅ BEGRENSES til eksterne IF
    
#    $IPTABLES -A input   -s $CLASS_A -j DROP 
#    $IPTABLES -A input   -s $CLASS_B -j DROP 
#    $IPTABLES -A input   -s $CLASS_C -j DROP 

    # Refuse broadcast address SOURCE packets
    $IPTABLES -A input   -s $BROADCAST_DEST -j LOGDROP
    $IPTABLES -A input   -d $BROADCAST_SRC -j LOGDROP

    # Refuse Class D multicast addresses
    # Multicast is illegal as a source address.
    # Multicast uses UDP.
    $IPTABLES -A input   -s $CLASS_D_MULTICAST -j LOGDROP 

    # Refuse Class E reserved IP  addresses
    $IPTABLES -A input   -s $CLASS_E_RESERVED_NET -j LOGDROP

    # Refuse addresses defined as reserved by the IANA.
    # Note:  this list includes the loopback addresses.

    # 0.*.*.*           - Can't be blocked for DHCP users.
    # 1.*.*.*, 2.*.*.*, 5.*.*.*, 7.*.*.*, 23.*.*.*, 27.*.*.*
    # 31.*.*.*, 37.*.*.*, 39.*.*.*, 41.*.*.*, 42.*.*.*, 58-60.*.*.*
    # 65-95.*.*.*, 96-127.*.*.*
    # 169.254.*.*       - Link Local Networks
    # 192.0.2.*         - TEST-NET
    # 217-223.*.*.*
    # 248.*.*.*         - Unallocated

    $IPTABLES -A input   -s 1.0.0.0/8 -j LOGDROP 
    $IPTABLES -A input   -s 2.0.0.0/8 -j LOGDROP
    $IPTABLES -A input   -s 5.0.0.0/8 -j LOGDROP
    $IPTABLES -A input   -s 7.0.0.0/8 -j LOGDROP
    $IPTABLES -A input   -s 23.0.0.0/8 -j LOGDROP
    $IPTABLES -A input   -s 27.0.0.0/8 -j LOGDROP
    $IPTABLES -A input   -s 31.0.0.0/8 -j LOGDROP
    $IPTABLES -A input   -s 37.0.0.0/8 -j LOGDROP
    $IPTABLES -A input   -s 39.0.0.0/8 -j LOGDROP
    $IPTABLES -A input   -s 41.0.0.0/8 -j LOGDROP
    $IPTABLES -A input   -s 42.0.0.0/8 -j LOGDROP
    $IPTABLES -A input   -s 58.0.0.0/7 -j LOGDROP
    $IPTABLES -A input   -s 60.0.0.0/8 -j LOGDROP
    $IPTABLES -A input   -s 65.0.0.0/8 -j LOGDROP
    $IPTABLES -A input   -s 66.0.0.0/7 -j LOGDROP
    $IPTABLES -A input   -s 68.0.0.0/6 -j LOGDROP
    $IPTABLES -A input   -s 72.0.0.0/5 -j LOGDROP
    $IPTABLES -A input   -s 80.0.0.0/4 -j LOGDROP
    $IPTABLES -A input   -s 96.0.0.0/3 -j LOGDROP
    $IPTABLES -A input   -s 169.254.0.0/16 -j LOGDROP
    $IPTABLES -A input   -s 192.0.2.0/24 -j LOGDROP
    $IPTABLES -A input   -s 217.0.0.0/8 -j LOGDROP
    $IPTABLES -A input   -s 218.0.0.0/7 -j LOGDROP
    $IPTABLES -A input   -s 220.0.0.0/6 -j LOGDROP
    $IPTABLES -A input   -s 248.0.0.0/5 -j LOGDROP


EOM

}

if ( $config{'badservice'} ) {
    print FILE "\necho Blocking bad services... \n" if $config{'verbose'};
     print FILE <<EOM;

# Avoid ports subject to protocol & system administration problems.

    # NFS: establishing a TCP connection
    $IPTABLES -A input  -i $EXTERNAL_INTERFACE -p tcp -y --destination-port $NFS_PORT -j LOGDROP
    $IPTABLES -A output -i $EXTERNAL_INTERFACE -p tcp -y --destination-port $NFS_PORT -j REJECT 

    # Xwindows: establishing a connection
    $IPTABLES -A input  -i $EXTERNAL_INTERFACE -p tcp -y --destination-port $XWINDOW_PORTS -j LOGDROP
    $IPTABLES -A output -i $EXTERNAL_INTERFACE -p tcp -y --destination-port $XWINDOW_PORTS -j REJECT 

    # SOCKS: establishing a connection
    $IPTABLES -A input  -i $EXTERNAL_INTERFACE -p tcp -y  --destination-port $SOCKS_PORT -j LOGDROP
    $IPTABLES -A output -i $EXTERNAL_INTERFACE -p tcp -y --destination-port $SOCKS_PORT -j REJECT 

# ----------------------------------------------------------------------------
# UDP UNPRIVILEGED PORTS
# Avoid ports subject to protocol & system administration problems.

    $IPTABLES -A input  -i $EXTERNAL_INTERFACE -p udp  --destination-port $NFS_PORT -j LOGDROP

    # UDP INCOMING TRACEROUTE
    # traceroute usually uses -S 32769:65535 -D 33434:33523

    $IPTABLES -A input  -i $EXTERNAL_INTERFACE -p udp --source-port $TRACEROUTE_SRC_PORTS --destination-port $TRACEROUTE_DEST_PORTS -j LOGDROP


    # DNS client (53)
    # ---------------
    $IPTABLES -A output -i $EXTERNAL_INTERFACE -p udp -s $IPADDR $UNPRIVPORTS -d $NAMESERVER_1 53 -j ACCEPT 
    $IPTABLES -A input  -i $EXTERNAL_INTERFACE -p udp -s $NAMESERVER_1 53 -d $IPADDR $UNPRIVPORTS -j ACCEPT 


    $IPTABLES -A output -i $EXTERNAL_INTERFACE -p tcp -s $IPADDR $UNPRIVPORTS -d $NAMESERVER_1 53 -j ACCEPT 
    $IPTABLES -A input  -i $EXTERNAL_INTERFACE -p tcp ! -y -s $NAMESERVER_1 53 -d $IPADDR $UNPRIVPORTS -j ACCEPT 



EOM

}
######## OPTIONS ###############################################



#################################################################
    $objects = &get_objects;
    $services = &get_objects( "servicefile" );		
    
    $chain = "";

    open(RF, $config{'rulefile'}) || &error($text{'sman_err_read'});  
    $nr = 0;	
    while (<RF>) {
     ( $S,$D,$P,@R ) = split(/,/);
           &script($nr,0, $S,$D,$P,@R );
	$nr++;
    }


 #  print "Chain:\n",$chain;
 #



print FILE "#Generated from rules:\n",$chain;

#### ICMP ############
$where = undef;
if ( $config{'icmp'} eq "first" ) { $where = "-I"; $r=1;}
if ( $config{'icmp'} eq "last" ) { $where = "-A"; $r="";}

if ($where ){
    print FILE "\necho ICMP policy ... \n" if $config{'verbose'};

print FILE <<EOM;

# ICMP  
    $IPTABLES $where INPUT $r -p icmp  -j ACCEPT 
    $IPTABLES $where OUTPUT $r  -p icmp -j ACCEPT
    $IPTABLES $where FORWARD $r -p icmp  -j ACCEPT

EOM
}

#### DNS ############
$where = undef;
if ( $config{'dns'} eq "first" ) { $where = "-I"; $r=1; }
if ( $config{'dns'} eq "last" ) { $where = "-A"; $r=""; }

if ($where ){
    print FILE "\necho DNS policy ... \n" if $config{'verbose'};

    print FILE <<EOM;

##### DNS ############
    $IPTABLES $where INPUT $r -p udp -d $ANYWHERE --destination-port domain  -j ACCEPT 
    $IPTABLES $where OUTPUT $r -p  udp -d $ANYWHERE --destination-port domain  -j ACCEPT 
    $IPTABLES $where FORWARD $r -p  udp -d $ANYWHERE --destination-port domain  -j ACCEPT

EOM
}

#### RIP ############
$where = undef;
if ( $config{'rip'} eq "first" ) { $where = "-I"; $r=1; }
if ( $config{'rip'} eq "last" ) { $where = "-A"; $r=""; }

if ($where ){
    print FILE "\necho RIP policy ... \n" if $config{'verbose'};
    print FILE <<EOM;

# RIP 
    $IPTABLES $where INPUT $r -p udp -d $ANYWHERE --destination-port route  -j ACCEPT 
    $IPTABLES $where OUTPUT $r -p  udp -d $ANYWHERE --destination-port route  -j ACCEPT 

EOM
}


#### REJECT Ident ( auth ) ############
$where = undef;
if ( $config{'auth'} eq "first" ) { $where = "-I"; $r=1;}
if ( $config{'auth'} eq "last" ) { $where = "-A"; $r="";}

if ($where ){
    print FILE "\necho Ident policy ... \n" if $config{'verbose'};
    
    print FILE <<EOM;

#### REJECT Ident ( auth ) ############
    $IPTABLES $where INPUT $r  -p tcp -d $ANYWHERE --destination-port auth  -j REJECT
    $IPTABLES $where FORWARD $r  -p tcp -d $ANYWHERE --destination-port auth  -j REJECT

EOM
}


#### DROP BROADCASTS ############
$where = undef;

if ( $config{'bcast'} eq "first" ) { $where = "-I"; $r=1; $AKSJON="DROP";}
if ( $config{'bcast'} eq "last" ) { $where = "-A"; $r="";$AKSJON="DROP";}
if ( $config{'bcast'} eq "a_first" ) { $where = "-I"; $r=1; $AKSJON="ACCEPT";}
if ( $config{'bcast'} eq "a_last" ) { $where = "-A"; $r="";$AKSJON="ACCEPT";}

if ($where ){
    print FILE "\necho Broadcast policy ... \n" if $config{'verbose'};
    print FILE <<EOM;

#### DROP BROADCASTS ############
    $IPTABLES $where INPUT $r -d $BROADCAST_SRC -j $AKSJON
    $IPTABLES $where INPUT $r -d $BROADCAST_DEST -j $AKSJON

EOM

### Interface broadcast addresses:

  open(IF, " ifconfig -a |")  or die "Kan ikke &aring;pne ifconfig \n";
  while (<IF>) {
    $L=$_;
    if ( $L =~ m/cast:([0-9.]*) .*/ ) {
	$bcast = $1;
	print FILE "$IPTABLES $where INPUT $r -d $bcast -j $AKSJON\n";
	print FILE "$IPTABLES $where OUTPUT $r -d $bcast -j $AKSJON\n";
    }    
  }
  close IF;
}


#### DROP NetBIOS ############
$where = undef;
if ( $config{'netbios'} eq "first" ) { $where = "-I"; $r=1;}
if ( $config{'netbios'} eq "last" ) { $where = "-A"; $r="";}

if ($where ){
    print FILE "\necho Netbios policy ... \n" if $config{'verbose'};
    print FILE <<EOM;

#### DROP NetBIOS ############
    $IPTABLES $where FORWARD $r -p udp -d $ANYWHERE --destination-port 137  -j DROP
    $IPTABLES $where FORWARD $r -p tcp -d $ANYWHERE --destination-port 137  -j DROP
    $IPTABLES $where FORWARD $r -p udp -d $ANYWHERE --destination-port 138  -j DROP
    $IPTABLES $where FORWARD $r -p tcp -d $ANYWHERE --destination-port 138  -j DROP

EOM
}


#### DROP BOOTP ############
$where = undef;
if ( $config{'bootp'} eq "first" ) { $where = "-I"; $r=1;}
if ( $config{'bootp'} eq "last" ) { $where = "-A"; $r="";}

if ($where ){
    print FILE "\necho Bootp policy ... \n" if $config{'verbose'};
    print FILE <<EOM;

#### DROP BOOTP ############
    $IPTABLES $where INPUT $r -p udp -d $ANYWHERE --destination-port 67  -j DROP
    $IPTABLES $where INPUT $r -p udp -d $ANYWHERE --destination-port 68  -j DROP

EOM
}

print FILE "\necho Established sessions ... \n" if $config{'verbose'};

print FILE <<EOM;
## Established 

$IPTABLES -I INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT 
$IPTABLES -I FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPT 
$IPTABLES -I OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT 
# $IPTABLES -A FORWARD -m limit --limit 3/minute --limit-burst 3 -j LOG \
#          --log-level INFO --log-prefix "IPT FORWARD packet died: "

EOM


if ( $config{'block'} eq "first" ) {
        print FILE "\necho Blocklist hook: insert first... \n" if $config{'verbose'};

  print FILE <<EOM;

# Blocklist
$IPTABLES -I  INPUT   -j BLOCK
$IPTABLES -I  FORWARD   -j BLOCK
$IPTABLES -I  OUTPUT   -j BLOCK

EOM

}

print FILE "\necho Default actions ... \n" if $config{'verbose'};

## Extra rules , transp. proxy, snat etc.
$extrascript = $config{'policypath'} ."/extra.rules";
print FILE <<EOM;

if [ -x $extrascript ] ; then
   $extrascript;
fi

# ----------------------------------------------------------------------------
# Default actions

#  Drop and log all packets.

    $IPTABLES -A INPUT   -j LOGDROP
    $IPTABLES -A OUTPUT   -j LOGDROP
    $IPTABLES -A FORWARD   -j LOGDROP

EOM


close(FILE);

print "<BR><HR></pre>\n";
#&footer("./script_manager.cgi", "Script manager");

}

#######################################################################################
############ Generate chains script for one rule ######################################
sub script {

	my ($nr, $l,$S,$D,$P,@R) = @_;
	($fraction,$log,$tos,$action,$disabled,$comment) = @R;
	if ($disabled){ return;}

        my $txt;
	
	if ( $l == 0 ) {        
	   $txt = "\n# Rule nr $nr: FRA ". $S . " TIL " . $D. " PORT " . $P;
	   $txt .= " Aksjon: $action, Log: $log, TOS: $tos\n";
	   $txt .= "#------------------------------------------------------------------------------\n";
	   $chain .= $txt;
	   print $txt;
	   $chain .= "\necho Rule nr $nr\n" if $config{'verbose'};

	   $rtos = $tos;
        }
	
	if ( $l > 10 ) { &error(" Possible object og service group loop, rule $nr "); }
	$src = $objects->{$S};
	if (!$src)  { &error (" Undefined object $S in source, rule $nr"); }
	if ( ref($src) eq  "group" ) {
		foreach my $elem ($src->members) {
			&script($nr, $l+1, $elem,$D,$P,@R );
		 }
	         return;
	}
	$dest = $objects->{$D};
	if (!$dest)  { &error (" Undefined object $D in destination, rule $nr"); }	
	if ( ref($dest) eq  "group" ) {
		foreach my $elem (sort $dest->members) {
			&script($nr, $l+1, $S,$elem,$P,@R );
		 }
	         return;
	}
	$serv = $services->{$P};
       
	if ( ref($serv) eq  "group" ) {
		foreach my $elem ($serv->members) {
			&script($nr, $l+1, $S,$D,$elem,@R );
		 }
	         return;
	}
	if ( $serv ) {
		$proto = $serv->proto;
		$port = $serv->port;
		$sport =$serv->sport; 
		$icmptype = $serv->icmptype;
		$tos = $serv->tos;
	}elsif( ($s = &getservice($P)) != NULL ){
		$proto = $s->{'proto'};
		$port = $s->{'port'};
		$sport =undef;
		$icmptype = undef;
		$tos = undef;
		
	}else{    
		print "WARNING: Service definition not found for proto  $P  in rule nr $nr ( $S -> $D )\n";
		$port = undef;
		$proto= undef;
	}

       if ( $S eq $D ) {
          print "\nWARNING: Source = Destination\n";
	  print "Level $l, Rule nr $nr: FRA ". $S . " TIL " . $D. " PORT " . $P ." ";
	  print "Aksjon: $action, Log: $log ";
	  print " Proto: $proto, Port: $port\n";
	
#	    return;
	}
###########################
# Her har vi en enkelt service, source og dest. Generer Input, forward og output 
	($s_if_n,$s_if) = split(/,/, $src->location);
	($d_if_n,$d_if) = split(/,/, $dest->location);
	$MASQIP = "INVALID";
	
# Regel TOS har presedens if set:	
	if ( $rtos eq "0x00" || $rtos eq "" ){
	  if ( $tos eq "0x00" ) {$tos = ""};
	} else {
	  $tos = $rtos;
	}  

    $chain .= "\n# Rule nr $nr: FRA ". $S ." on |".$s_if_n . "| TIL " . $D ." on |".$d_if_n . "| PORT " . $P ."\n";

    $d_is_FW = $s_is_FW = undef; 
    if ( $src->type eq "interface" ) {
        $s_is_FW = true;
	$chain .= "# SOURCE IS FIREWALL!\n";
	if ( $src->ip eq "0.0.0.0" && $src->netmask eq '' ){
	      $src->ip('$ADR_'.$s_if);
	}
    }
    
    if ( $dest->type eq "interface" ) {
        $d_is_FW = true;
	$chain .= "# DESTINATION IS FIREWALL!\n";
	if ( $dest->ip eq "0.0.0.0"  && $dest->netmask eq '' ){
	      $dest->ip('$ADR_'.$d_if);
	}
    }
    
$chain .="# S-IF: $s_if , D-IF: $d_if \n";    
    if ( ($action eq "ACCEPT") || ($action eq "MASQ" )) {
#	if ( $log ) { $line .= " -l"; }

        $masq = undef;
	if ($action eq "MASQ" ) {
	   $masq = true;
	}elsif($config{'automasq'}) {
#Implisitt regler 
          if( ($s_if_n eq "EXT") && ($d_if_n eq "DMZ")  ) { $masq = undef;}   
	   if( ($s_if_n eq "DMZ") && ($d_if_n eq "EXT")  ) { $masq = undef;}   
#	   if( ($s_if_n eq "COM")  ) { $masq = undef;}   	   
	   if( ($s_if_n eq "LAN") && ($d_if_n eq "EXT") ) { $masq = true;}   	   
	   if( ($s_if_n eq "LAN") && ($d_if_n eq "DMZ") ) { $masq = true;}   	   
        }
	$MASQIP = &if_ip($dest->location);
        $logline = undef;

	if ( ! $log_non_sessions && ($proto ne "tcp") ) {
	    $log=0;
	    }
	
	
#########################################################################
# Input if Source is NOT firewallW
#########################################################################
# $frag=($l->{'frag'}) ?  "X" : "&nbsp;";
      if ( $s_is_FW ){
        # output & log
      
# Output if D ! FW. S = FW
            if ( ! $d_is_FW ){
		
		
		$chain .= "# Accept packet OUT from FW on outgoing IF.....\n";		
		$out = "$IPTABLES -A OUTPUT ";
		$out .=&chain_param(undef,$src->ip,$src->netmask,$sport,$d_if,$dest->ip,$dest->netmask,$proto,$port,$icmptype); 	
		if ( $log  ){
		    $logline =   $out . " -j LOG --log-prefix \"$CFW:OUTPUT:ACCEPT RULE=$nr \"";
		    
		    $chain .= "# Log outgoing session\n";      
		    $chain .= $logline ."\n";
		}

		$line = $out . " -j ACCEPT";
		$chain .= "# Accept outgoing  session\n";
		$chain .= $line ."\n";

		$chain .= "# Do not translate packets\n";	  
		$natline = "$IPTABLES -t nat -A POSTROUTING ";
		$natline .=&chain_param(undef,$src->ip,$src->netmask,$sport,$d_if,$dest->ip,$dest->netmask,$proto,$port,$icmptype);
		$natline .=" -j ACCEPT";
		$chain .= $natline;
		$chain .= "\n";

             }
	  
      } else {  # S != FW
	
        if (  $d_is_FW ){  # Input chain.
	    $line = "$IPTABLES -A INPUT ";
	    $line .=&chain_param($s_if,$src->ip,$src->netmask,$sport,undef,$dest->ip,$dest->netmask,$proto,$port,$icmptype); 

	    if ( $log  ){
		$logline =   $line . " -j LOG --log-prefix \"$CFW:INPUT:ACCEPT RULE=$nr \"";
					
		$chain .= "# Log incoming session\n";      
		$chain .= $logline ."\n";
	    }

	    $line .=" -j ACCEPT";
	    $chain .= "# Accept incomming in session\n";
	    $chain .= $line ."\n";

        }else{
# Forward if D ! fw and S ! FW
#	$chain .="#DEST. IF != FW, IF NAME=$d_if_n \n";
	  $fline = "$IPTABLES -A FORWARD ";
	  $fline .=&chain_param($s_if,$src->ip,$src->netmask,$sport,$d_if,$dest->ip,$dest->netmask,$proto,$port,$icmptype);

	    
	  $natline = "$IPTABLES -t nat -A POSTROUTING ";
	  $natline .=&chain_param(undef,$src->ip,$src->netmask,$sport,$d_if,$dest->ip,$dest->netmask,$proto,$port,$icmptype);
	  if ($masq ) {
	      if ( $log  ){
		  $logline =   $natline . " -j LOG --log-prefix \"$CFW:POSTROUTING:MASQ RULE=$nr \"";
		  
		  $chain .= "# Log NATed session\n";      
		  $chain .= $logline ."\n";
	      }
	      $natline .=" -j MASQUERADE";
	      $chain .= "# Translate packets\n";	  
	      $chain .= $natline;
	      
	      $chain .= "\n";
	      
          }else{
	      if ( $log  ){
		  $logline =   $fline . " -j LOG --log-prefix \"$CFW:FORWARD:ACCEPT RULE=$nr \"";
		  
		  $chain .= "# Log forwarded session\n";      
		  $chain .= $logline ."\n";
	      }
	      $chain .= "# Do not translate packets\n";	  
	      $natline .=" -j ACCEPT";
	      $chain .= $natline;
	      
	      $chain .= "\n";
	  }		
	  $chain .= "# Forward packets\n";	  
	  $fline .=" -j ACCEPT";
	  $chain .= $fline;
	  
	  $chain .= "\n";
			  
	} # endif ( ! $d_is_FW )
	
      } # End source
      

    } else { # reject...
#	$line = "$IPTABLES -A input -s ". $src->ip ."/". $src->netmask;
#	$line .=" -d ". $dest->ip ."/". $dest->netmask ." ". $port;
	
	if ( $d_is_FW ){
	    $filter="INPUT";
	    $line = "$IPTABLES -A INPUT ";
	    $line .=&chain_param($s_if,$src->ip,$src->netmask,$sport,undef,$dest->ip,$dest->netmask,$proto,$port,$icmptype); 

	}elsif ( $s_is_FW ){

	    $filter="OUTPUT";
	    $line = "$IPTABLES -A OUTPUT ";
	    $line .=&chain_param(undef,$src->ip,$src->netmask,$sport,$d_if,$dest->ip,$dest->netmask,$proto,$port,$icmptype); 
	    
	}else{
	    $filter="FORWARD";
	    $line = "$IPTABLES -A FORWARD ";
	    $line .=&chain_param($s_if,$src->ip,$src->netmask,$sport,$d_if,$dest->ip,$dest->netmask,$proto,$port,$icmptype); 
	    
	}
	if ( $log ) {
	    $chain .= $line ." -j LOG --log-prefix \"$CFW:$filter:DROP RULE=$nr \"\n";	
	}
	$chain .= $line ." -j DROP\n";	
	    

    }
	


#	print @R;
}



sub add_reply {

my ($ch, $if,$sip,$snetmask,$sport,$dip,$dnetmask,$proto,$port,$icmptype) = @_;

	if( $proto eq "udp" ) {
		$chain .= "# Add (append) reply on interface $if to $ch chain. Proto = $proto\n";
		&make_reply ($ch,"A", $if,$sip,$snetmask,$sport,$dip,$dnetmask,$proto,$port,$icmptype);
	} elsif( ($proto eq "tcp") ) {
	        $ch = "REPLY-". uc( substr($ch,0,1));
		$chain .= "# Insert reply on interface $if to $ch chain.\n";
		&make_reply ($ch,"I", $if,$sip,$snetmask,$sport,$dip,$dnetmask,$proto,$port,$icmptype);
        } else {
	        $chain .= "# No auto reply on interface $if to $ch chain for proto $proto.\n";
	}
}

sub  insert_reply {

my ($ch, $if,$sip,$snetmask,$sport,$dip,$dnetmask,$proto,$port,$icmptype) = @_;
    $ch = "REPLY-". uc( substr($ch,0,1));
    $chain .= "# Add reply on interface $if to $ch chain.\n";
    &make_reply ($ch,"A", $if,$sip,$snetmask,$sport,$dip,$dnetmask,$proto,$port,$icmptype);
}


sub  make_reply {

my ($ch, $w, $if,$sip,$snetmask,$sport,$dip,$dnetmask,$proto,$port,$icmptype) = @_;

        $ret = "$IPTABLES -".$w." " . $ch ." ";
	if( ($proto eq "tcp") ||($proto eq "udp") ) {	
           $ret .= &chain_param($if,$sip,$snetmask,$sport,$dip,$dnetmask,$proto,$port,$icmptype);
	   if ($proto eq "tcp"){ $ret .= " ! -y"; }
	   if ( $spf ) { $ret .= " -o";}
	   $chain .= $ret ." -j ACCEPT\n";

        }
	if (( $proto eq "tcp") &&   &checkport($sport,21) ) { # ftp
	   $chain .="# ADDING FTP data channel \n";
	   $ret = "$IPTABLES -I ". $ch ." ";
           $ret .=&chain_param($if,$sip,$snetmask,20,$dip,$dnetmask,$proto,"1024:",undef);
	   if ( $spf ) { $ret .= " -o";}
	   $chain .= $ret ." -j ACCEPT\n";
	   
	}
}	

sub checkport  {
   my ($port, $cp ) = @_;

   my $f,$t;
   if ($port eq $cp ) { return $cp;}
   if ( !$port ) { return $cp;}
   
   if ( $port =~ m/(\d*):(\d*)/ ) {
      $f = ($1) ? $1 : 0;
      $t = ($2) ? $2 : 65535;
#print  " Fra = $f, Til = $t \n";   
       if ( (int($f) <= int($cp)) && ( int($cp) <= int($t)) ) { return $cp; }
   }
#print " Ikke funnet \n";   
   return undef;
   
}

sub chain_param {
	local ($s_if,$src_ip,$src_mask,$sport,$d_if,$dest_ip,$dest_mask,$proto,$port,$icmptype) = @_; 
	local $line = "";
	
	$line .= "-i $s_if " if ($s_if); 
    	$line .= "-o $d_if " if ($d_if); 
	$line .= ($src_ip) ? "-s ". $src_ip :"" ;
	$line .= ($src_mask) ? "/". $src_mask :"" ;
	
#        $line .=" -d ". $dest->ip ."/". $dest->netmask;
	$line .= ($dest_ip) ? " -d ". $dest_ip :"" ;
	$line .= ($dest_mask) ? "/". $dest_mask :"" ;


	if( ($proto eq "tcp") ||($proto eq "udp") ) {
           $line .= " -p ". $proto . " --destination-port ". $port;
	    if( $sport ){  $line .= " --source-port ". $sport;}
	}
	elsif( $proto eq "icmp" ) {
	    $line .= " -p icmp ";
	    if ( $icmptype ) { $line .= " --icmp-type " . $icmptype;}
	}
	elsif( $proto ne "Any" ) {
	    $line .= " -p ". $proto;
	}
	

	if ( $tos ne "" ) {
            $line .= " -t 0x01 ". $tos;
	}

#Merking av pakker/regler med regelnummer.	
#	$line .= " -m ". $nr;
	return $line;
}

sub getservice {
  my $n = shift;
  $n=~ /([^\/]+)\/?(.*)/;
   my $name= $1;
  my $proto = $2 ? $2 : "undef";
# print "Name: $name ,Proto: $proto \n";
 my @sl = &get_services;
    for $s (@sl){
	if( $s->{'name'} eq $name && ($s->{'proto'} eq $proto || $proto eq "undef" ) ) {
#	  print " Proto  $s->{'name'} ,$s->{'proto'}  found \n";	
	    return $s; 
	} 
    }
print " ERROR: service $n not found\n ";    
return FALSE;
 
}

sub trans {
   my $l = shift;

   if ( $text{$l} ){
      return $text{$l};
   }

   return $l . "(Undefined translation)";
}


sub if_ip {
   my $if = shift;
#   my %objects = @_;
   if (  $if eq "ALL"){
   	    return "0.0.0.0/0.0.0.0"; 
   }
   if ( !$objects) { $objects = &get_objects;}
   @sok =  keys %$objects;
    foreach $on (@sok) {
         $o = $objects->{$on};
	 if ( ($o->type eq "interface") && ( $o->location eq $if ))  
	 {
#	    return $o->ip ."/".$o->netmask; 
	    return $o->ip ."/32"; 
	 }
    }
   
    &error (" Undefined object for interface $if "); 	
}

1;
